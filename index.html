<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="performance.js"></script>
    <title>ASCII</title>
</head>
<body>
    <div style="display: flex;">
        <img id="lena-image" style="margin-right: 16px;">
        <canvas id="lena-canvas" style="display: none;"></canvas>
        <pre id="lena-ascii"></pre>
    </div>
    <script>

        perf();

        // ######
        // CONFIG
        // ######

        // Global public constants.
        let imgSrc = "lena.png",
            fontFamily = "Consolas",
            fontSize = "8px",
            lineHeight,
            letterSpacing,
            asciiVariety = 50; // Luminance variety. If 100, all ASCII characters. If 20, only 20% of all ASCII characters.
            // TODO: don't pick characters randomly but proportionally from start to finish,

        // TODO:
        // - levels of grey

        // Global objects.
        let imgObj,
            canvas,
            context,
            render;

        // ######
        // SCRIPT
        // ######

        lineHeight = lineHeight == null ? fontSize : lineHeight;

        window.onload = () => {
            setupImage();
        }

        /**
         * Sets up the image object.
         */
        const setupImage = () => {

            imgEl = document.querySelector("#lena-image");
            imgEl.src = imgSrc;

            imgObj = new Image();
            imgObj.crossOrigin = "Anonymous";
            imgObj.src = imgSrc;
            // img.src = "https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png";
            // img.src = "https://i.imgur.com/s4ITte7.jpg";
            // img.src = "https://i.imgur.com/E3M6hNM.png";
            // img.src = "https://i.imgur.com/Bk0nFbr.png";
            imgObj.addEventListener("load", () => {
                setupCanvas();
            }, false);
        }

        /**
         * Sets up the canvas element (and adds image inside the canvas).
         */
        const setupCanvas = () => {
            canvas = document.querySelector("#lena-canvas");
            canvas.width = imgObj.width;
            canvas.height = imgObj.height;

            context = canvas.getContext("2d");
            context.drawImage(imgObj, 0, 0);

            try {
                localStorage.setItem("saved-image-example", canvas.toDataURL("image/png"));
                setupRender();
            }
            catch(e) {
                console.log(e);
            }
        }

        /**
         * Sets up the rendering area.
         */
        const setupRender = () => {
            render = document.querySelector("#lena-ascii");
            render.style.width = `${imgObj.width}px`;
            render.style.height = `${imgObj.height}px`;
            render.style.fontFamily = fontFamily;
            render.style.fontSize = fontSize;
            render.style.lineHeight = lineHeight;
            render.style.letterSpacing = letterSpacing;
            render.style.border = "1px solid lightgrey";

            // Calibrates the rendering area by calculating how many rows and
            // columns are needed to render the ASCII art at the right dimensions.
            const result = calibrate(imgObj.width, imgObj.height, fontFamily, fontSize, lineHeight, letterSpacing),
                char = result.char,
                cols = result.cols,
                rows = result.rows;

            // Gets the whole raw image data.
            const rawImageData = context.getImageData(0, 0, canvas.width, canvas.height).data;

            /**
             * Contains an organized image data matrix, that is easily readable.
             * Contains rows, which contains columns, which contains RGB data in it.
             * It will be used to quickly access the image data to calculate the average
             * luminance for a square of pixels (ex: each 40px*40px, get average luminance).
             * @var {array}
             * @example If the image is 512px * 300px, it will have 300 rows with 512 columns each.
             * [
             *   [                  // Each entry is a row
             *     [87, 130, 187]   // Each entry is a column in a row, which contains RGB data.
             *     ...
             *   ],
             *   ...
             * ]
             */
            const imageData = [];

            // Inits the matrix.
            for (let x = 0; x < canvas.width; x++) {
                imageData[x] = [];
            }

            let index = 0;

            // Fill it with data.
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    imageData[x][y] = [rawImageData[index], rawImageData[index + 1], rawImageData[index + 2]];
                    index += 4;
                }
            }

            /**
             * Builds the matrix of average luminance value for each group of pixels.
             * @var {array}
             * @example If the image is 500px * 300px, and rows and cols size are 10px, it will have 30 rows with 50 columns each.
             * [
             *   [       // Each entry is a row
             *     70    // Each entry is a column in a row, which contains the average luminance value.
             *     ...
             *   ],
             *   ...
             * ]
             */
            let avgLuminanceMatrix = [];
            
            // Current position in the canvas rectangle.
            let x = 0,
                y = 0;

            // For each cols of the rendering area.
            for (let xi = 0; xi < cols; xi++) {

                let r, // Average RED pixel color of the current rectangle.
                    g, // ...     GREEN
                    b; // ...     BLUE

                // Inits the matrix row.
                avgLuminanceMatrix[xi] = [];
                
                // For each rows of the rendering area.
                for (let yi = 0; yi < rows; yi++) {

                    let rectX = Math.floor(x), // Rectangle's current position.
                        rectY = Math.floor(y),
                        rectR = [], // Array of all RED pixel values from the current rectangle.
                        rectG = [], // ...          GREEN
                        rectB = []; // ...          BLUE

                    // For each columns pixels in the current rectangle.
                    for (let rectXi = 0; rectXi < char.width; rectXi++) {

                        // For each rows pixels in the current rectangle.
                        for (let rectYi = 0; rectYi < char.height; rectYi++) {
                            rectR.push(imageData[rectX][rectY][0]);
                            rectG.push(imageData[rectX][rectY][1]);
                            rectB.push(imageData[rectX][rectY][2]);
                            rectY++;
                        }

                        rectY = Math.round(y);
                        rectX++;
                    }

                    // Gets the average color of all pixels on the selected zone (the size of an ASCII char).
                    r = Math.round(rectR.reduce((a,v,i)=>(a*i+v)/(i+1)));
                    g = Math.round(rectG.reduce((a,v,i)=>(a*i+v)/(i+1)));
                    b = Math.round(rectB.reduce((a,v,i)=>(a*i+v)/(i+1)));

                    // Adds the average luminance to the matrix.
                    avgLuminanceMatrix[xi][yi] = RGBtoHSL(r, g, b)[2];

                    y += char.height;
                    y = Math.round(y * 100) / 100;
                }
                
                y = 0;
                x += char.width;
                x = Math.round(x * 100) / 100;
            }

            renderImage(avgLuminanceMatrix, cols, rows);
        }

        // Method 1

        const renderImage = (avgLuminanceMatrix, cols, rows) => {
            // This array was calculated by the `orderASCIIByDarkness` function.
            // let asciiArray = [" ", "@"];
            let asciiArray = [" ", "`", ".", "'", "-", "_", ":", ",", "\"", "^", "~", ";", ">", "<", "!", "=", "*", "\\", "/", "+", "?", "r", "c", "|", "L", ")", "(", "v", "T", "7", "i", "s", "z", "]", "}", "J", "{", "[", "l", "t", "x", "Y", "F", "n", "u", "f", "C", "1", "j", "I", "3", "o", "2", "y", "5", "e", "a", "S", "k", "V", "h", "E", "P", "Z", "w", "K", "4", "U", "X", "9", "6", "p", "q", "b", "d", "m", "A", "H", "G", "R", "#", "O", "D", "%", "8", "W", "M", "N", "B", "$", "0", "g", "Q", "&", "@"];

            // If 100% is given, remove 0%.
            // If 75% is given, remove 25%.
            // If 0% is given, remove 100%.
            const percentageToRemove = 100 - asciiVariety;

            // Remove N percentage of ASCII elements, to make the color variety smaller or bigger.
            asciiArray = arrayRemovePercentage(asciiArray, percentageToRemove);

            asciiArray = asciiArray.reverse();

            /**
             * Gets the right ASCII character depending of its luminance.
             */
            const getAsciiCharacterFromLuminance = (luminance) => {
                return asciiArray[Math.round((asciiArray.length - 1) * (luminance / 100))];
            };

            let asciiString = "";

            // Fills up the ASCII string.
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    asciiString += getAsciiCharacterFromLuminance(avgLuminanceMatrix[x][y]);
                }
                asciiString += "\n";
            }

            // Displays the string.
            render.innerText = asciiString;

            perf();
            perfLog();
        }

        // Method 2

        // const renderImage = (avgLuminanceMatrix, cols, rows) => {
        //     let asciiArray = [
        //             ["&nbsp;"],
        //             ["`", ".", "'", ","],
        //             ["i", "s", "z"],
        //             ["I", "3", "2", "V"],
        //             ["W", "M", "N", "B", "$"]
        //         ];

        //     asciiArray = asciiArray.reverse();

        //     const getAsciiCharacterFromLuminance = (luminance) => {
        //         return asciiArray[Math.round((asciiArray.length - 1) * (luminance / 100))];
        //     };

        //     let asciiString = "";
        //     for (let y = 0; y < rows; y++) {
        //         for (let x = 0; x < cols; x++) {
        //             // console.log(y);
        //             let chosenCharset = getAsciiCharacterFromLuminance(avgLuminanceMatrix[x][y])
        //             asciiString += chosenCharset[randomIntFromInterval(0, chosenCharset.length - 1)];
        //         }
        //         asciiString += "\n";
        //     }

        //     render.innerText = asciiString;

        //     perf();
        //     perfLog();
        // }

        /**
         * Calculates the right character width and height needed to perfectly fill up the rendering
         * area by filling up a temporary character matrix and getting the real character dimensions.
         */
        const calibrate = (width, height, fontFamily, fontSize, lineHeight, letterSpacing) => {
            let rows = 100, // Number of rows which test the calibration's precision.
                cols = 100; // Same for columns.

            let calibratingArea = document.createElement("div");
            calibratingArea.setAttribute("id", "calibratingArea");
            calibratingArea.style.border = "1px solid lightgrey";
            calibratingArea.style.fontFamily = fontFamily;
            calibratingArea.style.fontSize = fontSize;
            calibratingArea.style.lineHeight = lineHeight;
            calibratingArea.style.letterSpacing = letterSpacing;
            calibratingArea.style.display = "inline-block";

            document.querySelector("body").appendChild(calibratingArea);

            // Step 1: generate a character matrix with default values to get an idea
            // of how much characters are needed to fit the given height and width.
            fillMatrix();

            let char = {
                width: calibratingArea.clientWidth / rows,
                height: calibratingArea.clientHeight / cols
            }

            // Step 2: calculate the right number of rows and columns needed to fill up the calibrating area.
            // We round the numbers at their base (1.7 is rounded to 1) so the cols/rows do not overflow the given height or width.
            rows = Math.floor(height / char.height),
            cols = Math.floor(width / char.width);

            calibratingArea.remove();

            return {
                char: char,
                rows: rows,
                cols: cols
            }

            // Step 3: now and we know the right number of rows and columns needed, we need to calculate the right line-height
            // and letter-spacing needed to fill up the remaining spacing between the right side of the matrix and
            // the calibrating area, and same for the bottom side.
            // We will use a 'while' loop to get to a precision of about 1 pixel.

            // /!\ Apparently, adjusting very thinly the letter-spacing and line-height is not working.
            // These properties do not take thin values into account...

            // Call the matrix once before starting the actual calibration.
            // fillMatrix();

            // let security = 0;
            // while (Math.round(calibratingArea.clientWidth) < width && Math.round(calibratingArea.clientHeight) < height) {
            //     if (Math.round(calibratingArea.clientWidth) < width) {
            //         letterSpacing += 0.001;
            //     }
            //     if (Math.round(calibratingArea.clientHeight) < height) {
            //         lineHeight += 0.009;
            //     }
            //     // Sets the news values.
            //     calibratingArea.style.letterSpacing = `${letterSpacing}em`;
            //     calibratingArea.style.lineHeight = `${lineHeight}em`;
            //     // Fills the calibrating area.
            //     fillMatrix();

            //     console.log("letter-spacing", letterSpacing, "line-height", lineHeight, calibratingArea.clientWidth, calibratingArea.clientHeight);

            //     security++;
            //     if (security >= 100) break;
            // }

            function fillMatrix() {
                let str = "";

                for (let i = 0; i < rows; i++) {
                    str += i ? "<br>" : "";
                    for (let y = 0; y < cols; y++) {
                        str += "0";
                    }
                }
                
                calibratingArea.innerHTML = str;
            }
        };

        const arrayRemovePercentage = (array, percentage) => {

            const arrayCopy = [...array];

            // Calculate the number of items to remove.
            const totalItemsToRemove = Math.round(arrayCopy.length * percentage / 100);

            // For each items ot remove.
            for (let i = 0; i < totalItemsToRemove; i++) {
                // Generate a random index.
                const index = Math.floor(Math.random() * arrayCopy.length);
                // Removes the item.
                arrayCopy.splice(index, 1);
            }

            return arrayCopy;
        };

        // Utils
        const RGBtoHSL = (r, g, b) => {
            // see https://en.wikipedia.org/wiki/HSL_and_HSV#Formal_derivation
            // convert r,g,b [0,255] range to [0,1]
            r = r / 255,
            g = g / 255,
            b = b / 255;
            // get the min and max of r,g,b
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            // lightness is the average of the largest and smallest color components
            var lum = (max + min) / 2;
            var hue;
            var sat;
            if (max == min) { // no saturation
                hue = 0;
                sat = 0;
            } else {
                var c = max - min; // chroma
                // saturation is simply the chroma scaled to fill
                // the interval [0, 1] for every combination of hue and lightness
                sat = c / (1 - Math.abs(2 * lum - 1));
                switch(max) {
                    case r:
                        hue = (g - b) / c;
                        // hue = ((g - b) / c) % 6;
                        // hue = (g - b) / c + (g < b ? 6 : 0);
                        break;
                    case g:
                        hue = (b - r) / c + 2;
                        break;
                    case b:
                        hue = (r - g) / c + 4;
                        break;
                }
            }
            hue = Math.round(hue * 60); // °
            sat = Math.round(sat * 100); // %
            lum = Math.round(lum * 100); // %
            return [hue, sat, lum];
        }

        function round(number) {
            return Math.round(number * 100) / 100;
        }

        function randomIntFromInterval(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min)
        }


        /**
         * Orders the given ASCII characters from the clearest to the darkness.
         * 
         * Ex: '.' (dot) has is clearer than '0' (zero) since it has less dark pixels.
         * 
         * |Original string (for single quote escaping):
         * |0123456789 !"#$%&\'()*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
         * |
         * |Sorted string (for single quote escaping):
         * | `.\'-_:,"^~;><!=*\\/+?rc|L)(vT7isz]}J{[ltxYFnufC1jI3o2y5eaSkVhEPZwK4UX96pqbdmAHGR#OD%8WMNB$0gQ&@
         */
        function orderASCIIByDarkness() {
            let canvas = document.createElement("canvas"),
                ctx = canvas.getContext("2d"),
                // String is slower than array, but easier to read and update.
                s = '0123456789 !"#$%&\'()*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',
                // s = ' `.\'-_:,"^~;><!=*\\/+?rc|L)(vT7isz]}J{[ltxYFnufC1jI3o2y5eaSkVhEPZwK4UX96pqbdmAHGR#OD%8WMNB$0gQ&@',
                // s = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " ", "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~"],
                // s = '0',
                sortedCharacters = [];

            canvas.height = 220;
            canvas.width = 130;
            canvas.style.border = "1px solid lightgrey";
            ctx.font = "230px Consolas";
            document.querySelector("body").appendChild(canvas);

            for (let i = 0; i < s.length; i++) {
            // for (let i = 0; i < 15; i++) {
                let char = s[i];
                // Appends the character.
                ctx.fillText(char, 0, 180);
                // Gets the lumiance points of the current caracter and adds them to an array..
                sortedCharacters.push([char, getLuminancePoints()]);
                // Resets the canvas.
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // Sorts the array by character points.
            sortedCharacters.sort(function(a, b) {
                return a[1] - b[1];
            });

            // Creates an array of the sorted caracters only.
            sortedCharacters = sortedCharacters.map(([char, value]) => char);

            // Creates a string.
            // let sortedString = "";
            // for (let i = 0; i < sortedCharacters.length; i++) {
            //     sortedString += sortedCharacters[i];
            // }

            // Returns the array and string of sorted characters.
            console.log(sortedCharacters, sortedCharacters.join());

            /**
             * Runs through each pixels of the canvas, and totals the luminance of each pixels.
             * 0 is black, 255 is white. The total is the number of points the character has.
             * The higher the points total is, the darker the caracter is in average.
             * 
             * Ex: '.' (dot) has is clearer than '0' (zero) since it has less dark pixels.
             * 
             * @returns {number} Total of points.
             */
            function getLuminancePoints() {
                let points = 0;
                // For each height pixels.
                for (let y = 0; y < canvas.height; y++) {
                    // For each width pixels.
                    for (let x = 0; x < canvas.width; x++) {
                        points += ctx.getImageData(x, y, 1, 1).data[3];
                    }
                }
                return points;
            }
        }

        // orderASCIIByDarkness();
        
    </script>
</body>
</html>